

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>s3torchconnector.s3reader.dcp_optimized &mdash; Amazon S3 Connector for PyTorch 1.5.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=e0a75244"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Amazon S3 Connector for PyTorch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Amazon S3 Connector for PyTorch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">s3torchconnector.s3reader.dcp_optimized</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for s3torchconnector.s3reader.dcp_optimized</h1><div class="highlight"><pre>
<span></span><span class="c1">#  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.</span>
<span class="c1">#  // SPDX-License-Identifier: BSD</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">DCP-Optimized S3 Reader provides these 3 optimizations:</span>
<span class="sd">1. Selective data fetching with range coalescing to only fetch required byte ranges</span>
<span class="sd">2. Per-item buffer management to reduce buffer allocation costs</span>
<span class="sd">3. Eliminating buffer copy by storing S3 chunks as memoryview references</span>

<span class="sd">Data Flow Overview:</span>
<span class="sd">    DCP.load(model_state_dict, storage_reader=s3_storage_reader)</span>
<span class="sd">        -&gt; read_metadata()                                          # reads .metadata file</span>
<span class="sd">        -&gt; set_up_storage_reader(metadata)                          # populates storage_data</span>
<span class="sd">        -&gt; prepare_local_plan(plan)                                 # (patched) sorts items, injects ranges to constructor</span>
<span class="sd">            -&gt; DCPOptimizedConstructor.set_item_ranges_by_file()</span>
<span class="sd">        -&gt; read_data(plan)                                          # per-file loop below</span>
<span class="sd">            -&gt; DCPOptimizedS3Reader __init__</span>
<span class="sd">                -&gt; _validate_and_coalesce_ranges()                  # validates and groups ItemRanges into RangeGroups</span>
<span class="sd">            -&gt; DCPOptimizedS3Reader read()/readinto()</span>
<span class="sd">                -&gt; _find_item_for_range()                           # returns item for given read request</span>
<span class="sd">                -&gt; [if new item] _get_item_buffer()                 # fetches item byte data</span>
<span class="sd">                    -&gt; [if new RangeGroup] _get_stream_for_item()   # creates new stream before fetching byte data</span>
<span class="sd">                    -&gt; 1: Handle leftover bytes from prev. chunk</span>
<span class="sd">                    -&gt; 2: Skip gap data from coalescing</span>
<span class="sd">                    -&gt; 3: Fetch remaining data from S3</span>
<span class="sd">                -&gt; _ItemViewBuffer read()/readinto()                # returns data from buffer</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">bisect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">cast</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">io</span><span class="w"> </span><span class="kn">import</span> <span class="n">SEEK_SET</span><span class="p">,</span> <span class="n">SEEK_CUR</span><span class="p">,</span> <span class="n">SEEK_END</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">s3torchconnectorclient._mountpoint_s3_client</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">ObjectInfo</span><span class="p">,</span>
    <span class="n">GetObjectStream</span><span class="p">,</span>
    <span class="n">HeadObjectResult</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.s3reader</span><span class="w"> </span><span class="kn">import</span> <span class="n">S3Reader</span>

<div class="viewcode-block" id="log">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.log">[docs]</a>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span></div>


<div class="viewcode-block" id="DEFAULT_MAX_GAP_SIZE">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.DEFAULT_MAX_GAP_SIZE">[docs]</a>
<span class="n">DEFAULT_MAX_GAP_SIZE</span> <span class="o">=</span> <span class="p">(</span>
    <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>
<span class="p">)</span>  <span class="c1"># default max gap between ranges such that they stay in the same stream</span></div>

<div class="viewcode-block" id="FIND_ITEM_ERROR_PREFIX">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.FIND_ITEM_ERROR_PREFIX">[docs]</a>
<span class="n">FIND_ITEM_ERROR_PREFIX</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;DCPOptimizedS3Reader only supports sequentially accessing provided ranges: &quot;</span>
<span class="p">)</span></div>

<div class="viewcode-block" id="FALLBACK_GUIDANCE">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.FALLBACK_GUIDANCE">[docs]</a>
<span class="n">FALLBACK_GUIDANCE</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;If this error is encountered with the default DCP reader (S3ReaderConstructor.dcp_optimized()) &quot;</span>
    <span class="s2">&quot;added in s3torchconnector v1.5.0, please refer to the troubleshooting doc &quot;</span>
    <span class="s2">&quot;(https://github.com/awslabs/s3-connector-for-pytorch/blob/main/docs/TROUBLESHOOTING.md#dcpoptimizeds3reader-errors).&quot;</span>
    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">For unsupported or non-DCP access patterns, use the generic reader: &quot;</span>
    <span class="s2">&quot;S3StorageReader(region, path, reader_constructor=S3ReaderConstructor.default())&quot;</span>
<span class="p">)</span></div>



<span class="nd">@dataclass</span>
<div class="viewcode-block" id="ItemRange">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.ItemRange">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ItemRange</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Byte range for a single DCP ReadItem (tensor). Inclusive start, exclusive end.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ItemRange.start">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.ItemRange.start">[docs]</a>
    <span class="n">start</span><span class="p">:</span> <span class="nb">int</span></div>

<div class="viewcode-block" id="ItemRange.end">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.ItemRange.end">[docs]</a>
    <span class="n">end</span><span class="p">:</span> <span class="nb">int</span></div>
</div>



<span class="nd">@dataclass</span>
<div class="viewcode-block" id="RangeGroup">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.RangeGroup">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RangeGroup</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Group of nearby ItemRanges that will share a single S3 range request.</span>

<span class="sd">    Created by coalescing ItemRanges with gaps &lt;= max_gap_size in _validate_and_coalesce_ranges.</span>
<span class="sd">    One S3 stream will serve all items in the RangeGroup sequentially.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RangeGroup.start">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.RangeGroup.start">[docs]</a>
    <span class="n">start</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># First byte of the group (= first item&#39;s start)</span></div>

<div class="viewcode-block" id="RangeGroup.end">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.RangeGroup.end">[docs]</a>
    <span class="n">end</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># Last byte of the group (= last item&#39;s end)</span></div>

<div class="viewcode-block" id="RangeGroup.item_ranges">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.RangeGroup.item_ranges">[docs]</a>
    <span class="n">item_ranges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ItemRange</span><span class="p">]</span>  <span class="c1"># Items within this group, in order</span></div>
</div>



<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">_StreamState</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tracks S3 stream position in current RangeGroup and buffered data between item reads.</span>

<span class="sd">    A single S3 stream may serve multiple items in a RangeGroup. This state tracks</span>
<span class="sd">        1. Where we are in that stream created for the current RangeGroup, and</span>
<span class="sd">        2. any leftover bytes from the previous chunk that belong to the next item.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">stream</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">GetObjectStream</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Current S3 stream for active RangeGroup</span>
    <span class="n">stream_position</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="p">(</span>
        <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span>  <span class="c1"># Current byte position in S3 stream; -1 as dummy init value</span>
    <span class="n">leftover</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">memoryview</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Unused bytes from end of last chunk read</span>


<span class="c1"># TODO: extend buffer for use in other S3Reader implementations after extensive testing</span>
<span class="k">class</span><span class="w"> </span><span class="nc">_ItemViewBuffer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A read-only buffer storing item data, in the form of multiple memoryview segments.</span>

<span class="sd">    Instead of copying S3 chunks into a growing BytesIO buffer, this class stores</span>
<span class="sd">    references to the original S3 chunks (typically 8MB parts) as memoryview segments.</span>
<span class="sd">    This allows us to reduce buffer allocation costs, saving time and memory.</span>

<span class="sd">    The buffer supports seek/read/readinto with logic that handles reads spanning</span>
<span class="sd">    multiple segments, similar to the file-access interface in io.BytesIO.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_segments&quot;</span><span class="p">,</span> <span class="s2">&quot;_offsets&quot;</span><span class="p">,</span> <span class="s2">&quot;_lengths&quot;</span><span class="p">,</span> <span class="s2">&quot;_size&quot;</span><span class="p">,</span> <span class="s2">&quot;_pos&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segments</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">memoryview</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># memoryview segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># start offset (within the item) of each segment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[]</span>
        <span class="p">)</span>  <span class="c1"># length of each segment (avoid recalculations from offset)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># total item length (sum of _lengths)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># current read position within the item</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">append_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">:</span> <span class="nb">memoryview</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Append a memoryview segment (ignored if empty).&quot;&quot;&quot;</span>

        <span class="n">seg_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">seg_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_len</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">+=</span> <span class="n">seg_len</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">whence</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;integer expected, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="n">SEEK_SET</span><span class="p">:</span>
            <span class="n">new_pos</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">elif</span> <span class="n">whence</span> <span class="o">==</span> <span class="n">SEEK_CUR</span><span class="p">:</span>
            <span class="n">new_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">elif</span> <span class="n">whence</span> <span class="o">==</span> <span class="n">SEEK_END</span><span class="p">:</span>
            <span class="n">new_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Seek must be passed SEEK_CUR, SEEK_SET, or SEEK_END&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">new_pos</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;negative seek value </span><span class="si">{</span><span class="n">new_pos</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Seeking past EOF is allowed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">new_pos</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the current pos position (like BytesIO.tell).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns byte copy of data from the buffer, using readinto() logic.</span>

<span class="sd">        Note that in DCP, only PyTorch&#39;s serialization.py:: _is_zipfile() magic</span>
<span class="sd">        number check (read(4)) uses read() instead of readinto().</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># DCPOptimizedS3Reader doesn&#39;t allow full read, and doesn&#39;t use full reads on items either.</span>
        <span class="k">assert</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Size cannot be None; full read is not supported&quot;</span>
        <span class="k">assert</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Size cannot be negative; full read is not supported&quot;</span>

        <span class="c1"># Fast path: PyTorch&#39;s serialization.py::_is_zipfile() reads first 4 bytes to check magic number.</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="c1"># TODO: eliminating bytes() conversion can save ~3% time? Requires interface changes.</span>
            <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_segments</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">4</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>

        <span class="c1"># Pass implementation to readinto()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">size</span> <span class="k">else</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">out</span><span class="p">)[:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read into pre-allocated buffer, copying across segment boundaries as needed.&quot;&quot;&quot;</span>
        <span class="c1"># Avoid creating new memoryview if input already is one</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="n">buf</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">memoryview</span><span class="p">)</span> <span class="k">else</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">dest</span><span class="o">.</span><span class="n">readonly</span><span class="p">,</span> <span class="s2">&quot;writable buffer required&quot;</span>

        <span class="n">dest_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span>

        <span class="k">if</span> <span class="n">dest_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Cache to avoid repeated attribute lookups in the loop</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segments</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offsets</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lengths</span>

        <span class="c1"># Find segment containing pos with binary search</span>
        <span class="c1"># bisect_right gives insertion point where pos &lt; offsets[i], -1 gives containing segment.</span>
        <span class="c1"># No caching optimisation, since torch.load jumps around (magic bytes, zip dir, tensor data)</span>
        <span class="n">seg_idx</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_right</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">seg_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Invalid segment index </span><span class="si">{</span><span class="n">seg_idx</span><span class="si">}</span><span class="s2"> for position </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bytes_to_read</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dest_len</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span>

        <span class="c1"># Copy from segments to dest, handling segment boundaries</span>
        <span class="k">while</span> <span class="n">written</span> <span class="o">&lt;</span> <span class="n">bytes_to_read</span><span class="p">:</span>
            <span class="n">seg_start</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span>
            <span class="n">seg_len</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span>
            <span class="n">seg</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span>

            <span class="c1"># Account for first chunk when pos &gt; seg_start</span>
            <span class="n">offset_in_seg</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">seg_start</span>

            <span class="c1"># Account for last chunk when bytes_to_read &lt; seg_len</span>
            <span class="n">available_in_seg</span> <span class="o">=</span> <span class="n">seg_len</span> <span class="o">-</span> <span class="n">offset_in_seg</span>
            <span class="n">bytes_left_to_read</span> <span class="o">=</span> <span class="n">bytes_to_read</span> <span class="o">-</span> <span class="n">written</span>
            <span class="n">copy_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bytes_left_to_read</span><span class="p">,</span> <span class="n">available_in_seg</span><span class="p">)</span>

            <span class="n">dest</span><span class="p">[</span><span class="n">written</span> <span class="p">:</span> <span class="n">written</span> <span class="o">+</span> <span class="n">copy_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span>
                <span class="n">offset_in_seg</span> <span class="p">:</span> <span class="n">offset_in_seg</span> <span class="o">+</span> <span class="n">copy_size</span>
            <span class="p">]</span>

            <span class="n">written</span> <span class="o">+=</span> <span class="n">copy_size</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">copy_size</span>
            <span class="n">seg_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">+=</span> <span class="n">written</span>
        <span class="k">return</span> <span class="n">written</span>


<div class="viewcode-block" id="DCPOptimizedS3Reader">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/index.html#s3torchconnector.s3reader.dcp_optimized.DCPOptimizedS3Reader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DCPOptimizedS3Reader</span><span class="p">(</span><span class="n">S3Reader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;S3 reader implementation optimized for PyTorch Distributed Checkpoint (DCP) loading.</span>

<span class="sd">    Provides up to 2x performance improvement over default sequential reader through:</span>

<span class="sd">        1. **Selective data fetching with range coalescing**: Uses byte range information from</span>
<span class="sd">        PyTorch&#39;s ``LoadPlan`` to only fetch required data. Groups nearby ranges within</span>
<span class="sd">        ``max_gap_size`` into single S3 streams to minimize first-byte latency while avoiding</span>
<span class="sd">        unnecessary data transfer.</span>

<span class="sd">        2. **Per-item buffer management**: Buffers per-item (per-tensor) instead of per-file. Each</span>
<span class="sd">        buffer stores only the required item&#39;s byte ranges and is discarded after PyTorch reads the</span>
<span class="sd">        item, which removes overhead of resizing large buffers and re-copying data repeatedly.</span>

<span class="sd">        3. **Eliminate buffer copy**: Custom ``_ItemViewBuffer`` stores S3 chunks as memoryview</span>
<span class="sd">        references instead of copying into BytesIO, avoiding allocation and copy overhead.</span>

<span class="sd">    **Requirements**:</span>

<span class="sd">    - DCP Loading - reader is only designed for usage via dcp_optimized reader_constructor for ``dcp.load()``</span>
<span class="sd">    - Pre-sorted list of item_ranges, injected automatically in ``prepare_local_plan``.</span>
<span class="sd">    - Sequential Access over exact item_ranges provided, also applied automatically by ``prepare_local_plan``</span>

<span class="sd">    **Usage**:</span>
<span class="sd">    Created automatically by ``DCPOptimizedConstructor`` when used with ``S3StorageReader`` and</span>
<span class="sd">    ``S3ReaderConstructor.dcp_optimized()``:</span>

<span class="sd">        reader_constructor = S3ReaderConstructor.dcp_optimized(max_gap_size=32*1024*1024)</span>
<span class="sd">        storage_reader = S3StorageReader(region, path, reader_constructor=reader_constructor)</span>
<span class="sd">        DCP.load(state_dict, storage_reader=storage_reader)</span>

<span class="sd">    **Error Handling**:</span>
<span class="sd">        Non-sequential access attempts raise ValueError.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bucket</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">item_ranges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ItemRange</span><span class="p">],</span>
        <span class="n">get_object_info</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Union</span><span class="p">[</span><span class="n">ObjectInfo</span><span class="p">,</span> <span class="n">HeadObjectResult</span><span class="p">]],</span>
        <span class="n">get_stream</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">GetObjectStream</span><span class="p">],</span>
        <span class="n">max_gap_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">DEFAULT_MAX_GAP_SIZE</span><span class="p">,</span>
        <span class="c1"># added float type to allow float(&quot;inf&quot;) / sys.maxsize for max_gap_size</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bucket</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bucket should be specified&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Key should be specified&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">item_ranges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;item_ranges must be a non-empty List[ItemRange] object&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_gap_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;max_gap_size must be int or float, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">max_gap_size</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">max_gap_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_gap_size must be non-negative&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bucket</span> <span class="o">=</span> <span class="n">bucket</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_object_info</span> <span class="o">=</span> <span class="n">get_object_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_stream</span> <span class="o">=</span> <span class="n">get_stream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_gap_size</span> <span class="o">=</span> <span class="n">max_gap_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># --- Range Processing ---</span>

        <span class="c1"># Filter zero-length ranges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_item_ranges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ItemRange</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">item_ranges</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span> <span class="o">!=</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_ranges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No non-empty ranges to read (all ranges were length 0)&quot;</span><span class="p">)</span>

        <span class="c1"># Coalesce nearby ranges into range groups that share S3 streams</span>
        <span class="c1"># _group_start_to_group: lookup dict for O(1) &quot;is this item first in its group?&quot; check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_start_to_group</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">RangeGroup</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_range_groups</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">RangeGroup</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_and_coalesce_ranges</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_item_ranges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_gap_size</span>
        <span class="p">)</span>

        <span class="c1"># --- States ---</span>

        <span class="c1"># Stream state (stores S3 stream, position, and leftover bytes between item reads)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="p">:</span> <span class="n">_StreamState</span> <span class="o">=</span> <span class="n">_StreamState</span><span class="p">()</span>

        <span class="c1"># Item buffer state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_item_iter</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ItemRange</span><span class="p">]</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_item_ranges</span>
        <span class="p">)</span>  <span class="c1"># sequential access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_item</span><span class="p">:</span> <span class="n">ItemRange</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_item_iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_ItemViewBuffer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Current position in the overall S3 object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="DCPOptimizedS3Reader.bucket">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.DCPOptimizedS3Reader.bucket">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bucket</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bucket</span></div>


    <span class="nd">@property</span>
<div class="viewcode-block" id="DCPOptimizedS3Reader.key">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.DCPOptimizedS3Reader.key">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span></div>


    <span class="nd">@property</span>
<div class="viewcode-block" id="DCPOptimizedS3Reader.closed">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/dcp_optimized/index.html#s3torchconnector.s3reader.dcp_optimized.DCPOptimizedS3Reader.closed">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            bool: Return whether the object is closed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_and_coalesce_ranges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ranges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ItemRange</span><span class="p">],</span>
        <span class="n">max_gap_size</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">RangeGroup</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate ranges and coalesce nearby ranges into RangeGroups.</span>

<span class="sd">        - Validate: 1/ start&lt;=end, 2/ non-negative, 3/ sorted by start position, 4/ non-overlapping</span>
<span class="sd">        - Coalesce: Group nearby ranges where gap &lt;= max_gap_size into RangeGroup (one S3 stream).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">groups</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">RangeGroup</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">items</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ItemRange</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid range: </span><span class="si">{</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>  <span class="c1"># Empty ranges filtered out in __init__</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid range: </span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unsorted ranges: </span><span class="si">{</span><span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Overlapping ranges: </span><span class="si">{</span><span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="c1"># Coalesce or create new group</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;=</span> <span class="n">max_gap_size</span><span class="p">:</span>
                <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">RangeGroup</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span>
                <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_group_start_to_group</span><span class="p">[</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>
                <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">]</span>

        <span class="n">final_group</span> <span class="o">=</span> <span class="n">RangeGroup</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">items</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_group_start_to_group</span><span class="p">[</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_group</span>
        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_group</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">groups</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_item_for_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ItemRange</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find which item contains the requested range [start,end), enforcing sequential access.</span>

<span class="sd">        Returns current item if range is within it, and advances to / returns next item if the</span>
<span class="sd">        range is within the next item.</span>

<span class="sd">        Raises human-readable errors if the range is partially/fully outside of current or next items.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_item</span>

        <span class="c1"># Check if requested range is within current item</span>
        <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">item</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">item</span>

        <span class="c1"># 1. If start &lt; item.end and range not within current item, raise error</span>
        <span class="c1"># 2. Protection against reading 2nd item before first item by checking if buffer</span>
        <span class="c1"># contains any data (since we initialize with 1st item instead of None)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">item</span><span class="o">.</span><span class="n">end</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">FIND_ITEM_ERROR_PREFIX</span><span class="si">}</span><span class="s2">Range </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2"> not contained in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;current item </span><span class="si">{</span><span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">item</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{</span><span class="n">FALLBACK_GUIDANCE</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Advance to next item</span>
        <span class="n">prev_item</span> <span class="o">=</span> <span class="n">item</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_item_iter</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">FIND_ITEM_ERROR_PREFIX</span><span class="si">}</span><span class="s2">Range </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2"> not contained in last item &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with range </span><span class="si">{</span><span class="n">prev_item</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">prev_item</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{</span><span class="n">FALLBACK_GUIDANCE</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check if requested range is within next item</span>
        <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">item</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">item</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">FIND_ITEM_ERROR_PREFIX</span><span class="si">}</span><span class="s2">Range </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2"> not contained in &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;current item </span><span class="si">{</span><span class="n">prev_item</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">prev_item</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2"> nor the &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;next item </span><span class="si">{</span><span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">item</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{</span><span class="n">FALLBACK_GUIDANCE</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_stream_for_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">ItemRange</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GetObjectStream</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or create S3 stream for the given item.</span>

<span class="sd">        Creates new stream if item is first in its RangeGroup, otherwise reuse stream.</span>

<span class="sd">        Each RangeGroup maps to a contiguous byte range in S3, and items within a</span>
<span class="sd">        RangeGroup are read sequentially from the same stream.</span>

<span class="sd">        Sequential access is already enforced in _find_item_for_range, which runs</span>
<span class="sd">        before _get_item_buffer (which calls this method). Reading the first item will</span>
<span class="sd">        trigger stream creation, and subsequent reads will simply reuse the stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If item is the first item of a new group, create new stream</span>
        <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_start_to_group</span><span class="p">:</span>
            <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_group_start_to_group</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span> <span class="o">=</span> <span class="n">_StreamState</span><span class="p">(</span>
                <span class="n">stream</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_stream</span><span class="p">(</span><span class="n">group</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">group</span><span class="o">.</span><span class="n">end</span><span class="p">),</span>
                <span class="n">stream_position</span><span class="o">=</span><span class="n">group</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                <span class="n">leftover</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="o">.</span><span class="n">stream</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="o">.</span><span class="n">stream</span>

        <span class="c1"># Otherwise, we&#39;re still in same group - reuse stream created when reading 1st item</span>
        <span class="k">assert</span> <span class="p">(</span>  <span class="c1"># Assert mainly serves for mypy checks.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="o">.</span><span class="n">stream</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;No stream found for item; first item of its range group likely not read&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="o">.</span><span class="n">stream</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_item_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">ItemRange</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_ItemViewBuffer</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load entire item into a memoryview-segment buffer from existing stream.</span>

<span class="sd">        1. Handles leftover bytes from previous reads</span>
<span class="sd">        2. Skips gap data from coalescing within &lt;=max_gap_size</span>
<span class="sd">        3. Fetches item data from S3 stream into buffer</span>

<span class="sd">        Returns buffer ready for read/readinto calls.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">buffer</span> <span class="o">=</span> <span class="n">_ItemViewBuffer</span><span class="p">()</span>

        <span class="c1"># Get stream from the right RangeGroup for start_pos</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_stream_for_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="o">.</span><span class="n">stream_position</span>  <span class="c1"># global offset in S3 object</span>
        <span class="n">leftover</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="o">.</span><span class="n">leftover</span>  <span class="c1"># leftover from previous chunk</span>
        <span class="n">bytes_left</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span>

        <span class="c1"># --- Phase 1: Handle leftover bytes from previous chunk ---</span>
        <span class="c1">#</span>
        <span class="c1"># Leftover contains bytes from the end of the previous chunk (say 8MB) that weren&#39;t consumed.</span>
        <span class="c1"># The leftover always ends at a chunk boundary (of 8MB parts - assume 8MB from now for explanation)</span>
        <span class="c1">#</span>
        <span class="c1"># Two cases:</span>
        <span class="c1">#   A) item.start within leftover: extract needed portion, possibly</span>
        <span class="c1">#      i) skipping a prefix (gap data from coalescing ranges within max_gap_size), and/or</span>
        <span class="c1">#      ii) saving a suffix (next item&#39;s data) as new leftover</span>
        <span class="c1">#   B) item.start beyond leftover: discard all (gap data from coalescing ranges)</span>
        <span class="c1">#</span>
        <span class="c1"># Case A visualization (item starts within leftover):</span>
        <span class="c1">#</span>
        <span class="c1">#   8MB chunks: ...====|================================|====...</span>
        <span class="c1">#   leftover:                     |#####################|           (length: leftover_len)</span>
        <span class="c1">#                                 ^                     ^</span>
        <span class="c1">#                                pos             leftover_end_pos   (global position in object)</span>
        <span class="c1">#   Slice offsets:                |gap|used|new_leftover|           (gap/new_leftover can be empty)</span>
        <span class="c1">#                                     ^    ^</span>
        <span class="c1">#                              item.start item.end                  (global position in object)</span>
        <span class="c1">#                       start_in_leftover  end_in_leftover          (relative to leftover)</span>
        <span class="c1">#   Lengths:                          |&lt;---------------&gt;|</span>
        <span class="c1">#                                       available_bytes</span>
        <span class="c1">#                                     |&lt;--&gt;|</span>
        <span class="c1">#                                 bytes_to_extract</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">leftover</span><span class="p">:</span>
            <span class="n">leftover_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leftover</span><span class="p">)</span>
            <span class="n">leftover_end_pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">leftover_len</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">leftover_end_pos</span><span class="p">:</span>
                <span class="c1"># Case A: Item starts within leftover data:</span>
                <span class="c1"># i) if there&#39;s gap data to skip, ignore it</span>
                <span class="n">start_in_leftover</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">pos</span>
                <span class="c1"># ii) if more bytes than required, save suffix as new leftover</span>
                <span class="n">available_bytes</span> <span class="o">=</span> <span class="n">leftover_len</span> <span class="o">-</span> <span class="n">start_in_leftover</span>
                <span class="n">bytes_to_extract</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bytes_left</span><span class="p">,</span> <span class="n">available_bytes</span><span class="p">)</span>
                <span class="n">end_in_leftover</span> <span class="o">=</span> <span class="n">start_in_leftover</span> <span class="o">+</span> <span class="n">bytes_to_extract</span>

                <span class="c1"># Extract needed portion to buffer, and update leftover</span>
                <span class="n">buffer</span><span class="o">.</span><span class="n">append_view</span><span class="p">(</span><span class="n">leftover</span><span class="p">[</span><span class="n">start_in_leftover</span><span class="p">:</span><span class="n">end_in_leftover</span><span class="p">])</span>
                <span class="n">bytes_left</span> <span class="o">-=</span> <span class="n">bytes_to_extract</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">bytes_to_extract</span>
                <span class="n">leftover</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># Update &#39;new_leftover&#39;</span>
                    <span class="n">leftover</span><span class="p">[</span><span class="n">end_in_leftover</span><span class="p">:]</span>
                    <span class="k">if</span> <span class="n">end_in_leftover</span> <span class="o">&lt;</span> <span class="n">leftover_len</span>
                    <span class="k">else</span> <span class="kc">None</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># i.e. leftover_end_pos &lt;= item.start:</span>
                <span class="c1"># Case B: Item beyond leftover: discard leftover (it was gap data)</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="n">leftover_len</span>
                <span class="n">leftover</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># --- Phase 2: Skip gap data (from coalescing) ---</span>
        <span class="c1"># Current state: pos is at chunk boundary of 8MB parts after any leftover is processed.</span>
        <span class="c1"># When ranges are coalesced (within max_gap_size), there may be gap data to skip.</span>
        <span class="c1"># So we iterate stream until chunk contains item.start.</span>
        <span class="c1">#</span>
        <span class="c1"># Two cases per chunk:</span>
        <span class="c1">#   A) Full chunk is gap: discard entirely, continue till pos &gt;= item.start</span>
        <span class="c1">#   B) Boundary chunk: current chunk contains item.start</span>
        <span class="c1">#</span>
        <span class="c1"># Case B visualization (boundary chunk):</span>
        <span class="c1">#</span>
        <span class="c1">#   8MB chunks: ...====|================================|====...</span>
        <span class="c1">#   Fetched chunk:     |################################|           (length: chunk_len)</span>
        <span class="c1">#                      ^                                ^</span>
        <span class="c1">#                     pos                          pos+chunk_len</span>
        <span class="c1">#   Slice offsets:     | gap |   used   | new_leftover  |           (gap/new_leftover can be empty)</span>
        <span class="c1">#                            ^          ^</span>
        <span class="c1">#                     item.start     item.end                       (global position in object)</span>
        <span class="c1">#   Lengths:           |&lt;---&gt;|</span>
        <span class="c1">#                    skip_bytes</span>
        <span class="c1">#</span>
        <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">stream</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;S3 stream exhausted at position </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2"> before reaching item </span><span class="si">{</span><span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">item</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">chunk_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">chunk_len</span> <span class="o">&lt;=</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                <span class="c1"># Entire chunk before item start - skip completely</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="n">chunk_len</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Partial Skip - slice off unwanted part first</span>
                <span class="n">skip_bytes</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="n">pos</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="n">skip_bytes</span><span class="p">:]</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span>
                <span class="n">chunk_len</span> <span class="o">-=</span> <span class="n">skip_bytes</span>

                <span class="c1"># Now process boundary chunk</span>
                <span class="k">if</span> <span class="n">chunk_len</span> <span class="o">&lt;=</span> <span class="n">bytes_left</span><span class="p">:</span>
                    <span class="c1"># Entire chunk needed - skip slicing</span>
                    <span class="n">buffer</span><span class="o">.</span><span class="n">append_view</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                    <span class="n">bytes_left</span> <span class="o">-=</span> <span class="n">chunk_len</span>
                    <span class="n">pos</span> <span class="o">+=</span> <span class="n">chunk_len</span>
                    <span class="n">leftover</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Only part of chunk needed</span>
                    <span class="n">buffer</span><span class="o">.</span><span class="n">append_view</span><span class="p">(</span><span class="n">chunk</span><span class="p">[:</span><span class="n">bytes_left</span><span class="p">])</span>
                    <span class="n">leftover</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="n">bytes_left</span><span class="p">:]</span>
                    <span class="n">pos</span> <span class="o">+=</span> <span class="n">bytes_left</span>
                    <span class="n">bytes_left</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">break</span>

        <span class="c1"># --- Phase 3: Fetch remaining item data ---</span>
        <span class="c1"># Current state: pos is at chunk boundary, and pos == item.start + [bytes extracted]</span>
        <span class="c1"># If bytes_left &gt; 0, we still need more data for this item.</span>
        <span class="c1">#</span>
        <span class="c1"># Two cases per chunk:</span>
        <span class="c1">#   A) Full chunk needed: add all used bytes to buffer, continue if bytes_left &gt; 0</span>
        <span class="c1">#   B) Partial chunk: item ends mid-chunk, add used bytes to buffer and update leftover</span>
        <span class="c1">#</span>
        <span class="c1"># Case B visualization (partial chunk):</span>
        <span class="c1">#</span>
        <span class="c1">#   8MB chunks: ...====|================================|====...</span>
        <span class="c1">#   Fetched chunk:     |################################|           (length: chunk_len)</span>
        <span class="c1">#                      ^                                ^</span>
        <span class="c1">#                     pos                          pos+chunk_len</span>
        <span class="c1">#   Slice offsets:     |  used  |      new_leftover     |</span>
        <span class="c1">#                      ^        ^</span>
        <span class="c1">#                     pos      item.end                             (global position in object)</span>
        <span class="c1">#   Lengths:           |&lt;------&gt;|</span>
        <span class="c1">#                      bytes_left                                   (bytes_left only if item ends here)</span>
        <span class="c1">#</span>
        <span class="k">while</span> <span class="n">bytes_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">stream</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;S3 stream exhausted at position </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2"> while reading item </span><span class="si">{</span><span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">item</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">chunk_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">chunk_len</span> <span class="o">&lt;=</span> <span class="n">bytes_left</span><span class="p">:</span>
                <span class="c1"># Entire chunk needed - skip slicing</span>
                <span class="n">buffer</span><span class="o">.</span><span class="n">append_view</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
                <span class="n">bytes_left</span> <span class="o">-=</span> <span class="n">chunk_len</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="n">chunk_len</span>
                <span class="n">leftover</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Only part of chunk needed</span>
                <span class="n">buffer</span><span class="o">.</span><span class="n">append_view</span><span class="p">(</span><span class="n">chunk</span><span class="p">[:</span><span class="n">bytes_left</span><span class="p">])</span>
                <span class="n">leftover</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="n">bytes_left</span><span class="p">:]</span>  <span class="c1"># new_leftover</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="n">bytes_left</span>
                <span class="n">bytes_left</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="o">.</span><span class="n">stream_position</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="o">.</span><span class="n">leftover</span> <span class="o">=</span> <span class="n">leftover</span>
        <span class="k">return</span> <span class="n">buffer</span>

<div class="viewcode-block" id="DCPOptimizedS3Reader.read">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/index.html#s3torchconnector.s3reader.dcp_optimized.DCPOptimizedS3Reader.read">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read up to size bytes from the current position.</span>

<span class="sd">        Supports backward seeking within the current item buffer, but forward-only</span>
<span class="sd">        access across DCP items (sequential item access required).</span>

<span class="sd">        Args:</span>
<span class="sd">            size (int): how many bytes to read.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bytes: Bytes read from specified range.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If size is not an integer.</span>
<span class="sd">            ValueError: If position is outside valid DCP ranges, and if size is None or negative (full file reads not supported).</span>
<span class="sd">            S3Exception: An error occurred accessing S3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Size cannot be None; full read not supported.</span><span class="se">\n</span><span class="si">{</span><span class="n">FALLBACK_GUIDANCE</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;argument should be integer or None, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Size cannot be negative; full read not supported.</span><span class="se">\n</span><span class="si">{</span><span class="n">FALLBACK_GUIDANCE</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>

        <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_item_for_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>

        <span class="c1"># if item has been changed (or first item), then load new item to buffer</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_item</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_item</span> <span class="o">=</span> <span class="n">item</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_buffer</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="c1"># Convert global position to item-relative offset for buffer seek</span>
        <span class="n">local_pos_in_item_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">-</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">local_pos_in_item_buffer</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="DCPOptimizedS3Reader.readinto">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/index.html#s3torchconnector.s3reader.dcp_optimized.DCPOptimizedS3Reader.readinto">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">readinto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read up to len(buf) bytes into a pre-allocated, writable bytes-like object buf.</span>
<span class="sd">        Return the number of bytes read. If no bytes are available, zero is returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            buf : writable bytes-like object</span>

<span class="sd">        Returns:</span>
<span class="sd">            int : number of bytes read or zero, if no bytes available</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If position is outside valid DCP ranges.</span>
<span class="sd">            TypeError: If buf is not writable.</span>
<span class="sd">            S3Exception: An error occurred accessing S3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_item_for_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span>

        <span class="c1"># if item has been changed (or first item), then load new item to buffer</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_item</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_item</span> <span class="o">=</span> <span class="n">item</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_buffer</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="c1"># Convert global position to item-relative offset for buffer seek</span>
        <span class="n">local_pos_in_item_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">-</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">local_pos_in_item_buffer</span><span class="p">)</span>
        <span class="n">bytes_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">+=</span> <span class="n">bytes_read</span>
        <span class="k">return</span> <span class="n">bytes_read</span></div>


<div class="viewcode-block" id="DCPOptimizedS3Reader.seek">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/index.html#s3torchconnector.s3reader.dcp_optimized.DCPOptimizedS3Reader.seek">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">whence</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">SEEK_SET</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change position within DCP ranges, interpreted relative to whence.</span>

<span class="sd">        Supports arbitrary seeking within current item buffer, but only forward</span>
<span class="sd">        sequential access across DCP items (cannot seek back to previous items).</span>

<span class="sd">        Args:</span>
<span class="sd">            offset (int): How many bytes to seek relative to whence.</span>
<span class="sd">            whence (int): One of SEEK_SET, and SEEK_CUR. SEEK_END not supported. Default: SEEK_SET.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Current position of the stream</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If whence is not SEEK_SET or SEEK_CUR.</span>
<span class="sd">            ValueError: If seeking to negative position or accessing previous items.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;integer argument expected, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">whence</span> <span class="o">==</span> <span class="n">SEEK_SET</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="k">elif</span> <span class="n">whence</span> <span class="o">==</span> <span class="n">SEEK_CUR</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">+=</span> <span class="n">offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;whence must be SEEK_CUR or SEEK_SET integers&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;negative seek value </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_position</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span></div>


<div class="viewcode-block" id="DCPOptimizedS3Reader.tell">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/index.html#s3torchconnector.s3reader.dcp_optimized.DCPOptimizedS3Reader.tell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            int: Current absolute position in the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position</span></div>


<div class="viewcode-block" id="DCPOptimizedS3Reader.close">
<a class="viewcode-back" href="../../../autoapi/s3torchconnector/s3reader/index.html#s3torchconnector.s3reader.dcp_optimized.DCPOptimizedS3Reader.close">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close the stream and release resources.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stream_state</span><span class="o">.</span><span class="n">leftover</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current_item_buffer</span> <span class="o">=</span> <span class="kc">None</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Amazon S3.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>